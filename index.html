<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Landscape Runner — HTML Game</title>
  <style>
    /* Basic reset */
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:#0b1020;font-family:Inter,Arial,Helvetica,sans-serif;color:#fff}

    /* Full-screen landscape game area */
    #wrap{
      width:100vw;
      height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      position:relative;
      background: linear-gradient(180deg,#1b2a47 0%, #0b1020 60%);
    }

    /* Canvas fills the width in landscape; keep aspect ratio */
    canvas#game {
      width:100%;
      height:100%;
      display:block;
      max-height:100vh;
    }

    /* HUD */
    .hud{
      position:absolute;
      top:12px;
      left:12px;
      font-weight:700;
      letter-spacing:1px;
      background:rgba(0,0,0,0.25);
      padding:8px 12px;
      border-radius:10px;
      backdrop-filter: blur(4px);
    }
    .hud .score{font-size:18px}

    /* Rotate warning for portrait phones */
    #rotateHint{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:40;
      background:rgba(0,0,0,0.6);backdrop-filter:blur(4px);text-align:center;padding:20px;display:none
    }
    #rotateHint p{max-width:420px}

    /* Touch controls (mobile) */
    .controls{
      position:absolute;bottom:18px;left:50%;transform:translateX(-50%);display:flex;gap:18px;z-index:30
    }
    .btn{
      width:78px;height:56px;border-radius:12px;background:rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;color:#fff;user-select:none
    }
    .btn:active{transform:scale(0.98)}

    /* Small hint */
    .hint{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.25);padding:6px 10px;border-radius:10px;font-size:13px}

    /* Restart overlay */
    #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:50;pointer-events:none}
    #overlay .panel{background:rgba(0,0,0,0.7);padding:24px;border-radius:14px;text-align:center;pointer-events:auto}
    #overlay .panel h2{margin-bottom:10px}
    #overlay .panel button{margin-top:12px;padding:10px 16px;border-radius:8px;border:0;background:#1db954;color:white;font-weight:700}

    @media (orientation:portrait){
      #rotateHint{display:flex}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1280" height="720"></canvas>

    <div class="hud">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="speed" style="font-size:12px;opacity:0.9">Speed: <span id="spd">1.0</span></div>
    </div>

    <div class="hint">Keys: ↑ / Space = Jump</div>

    <div class="controls" id="controls">
      <div class="btn" id="jumpBtn">JUMP</div>
      <div class="btn" id="duckBtn">DUCK</div>
    </div>

    <div id="rotateHint"><p>Putar perangkat ke mode <strong>landscape</strong> untuk pengalaman terbaik. Jika menggunakan komputer — cukup resize jendela lebih lebar.</p></div>

    <div id="overlay" style="display:none">
      <div class="panel">
        <h2 id="overlayTitle">Game Over</h2>
        <div>Score: <strong id="finalScore">0</strong></div>
        <button id="restart">Main Lagi</button>
      </div>
    </div>
  </div>

  <script>
    /* Simple landscape endless runner
       Controls: Space or Up arrow to jump. Touch the JUMP button on mobile.
    */

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    // internal resolution (kept fixed for consistent gameplay)
    const GAME_W = 1280, GAME_H = 720;
    canvas.width = GAME_W; canvas.height = GAME_H;

    // HUD elements
    const scoreEl = document.getElementById('score');
    const spdEl = document.getElementById('spd');
    const overlay = document.getElementById('overlay');
    const finalScore = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restart');

    // Controls
    const jumpBtn = document.getElementById('jumpBtn');
    const duckBtn = document.getElementById('duckBtn');

    // Game state
    let running = true;
    let score = 0;
    let speed = 6; // world speed
    let gravity = 0.9;
    let groundY = GAME_H - 120;

    // Player
    const player = {
      x:160,
      y:groundY - 80,
      w:60,
      h:80,
      vy:0,
      onGround:true,
      duck:false
    };

    // Obstacles
    let obstacles = [];
    let spawnTimer = 0;

    function reset(){
      running = true; score = 0; speed = 6; obstacles = []; spawnTimer = 0; player.y = groundY - player.h; player.vy = 0; player.onGround = true; overlay.style.display = 'none';
    }

    restartBtn.addEventListener('click', ()=>{ reset(); loop(performance.now()); });

    function spawnObstacle(){
      const h = 40 + Math.random()*80;
      const w = 30 + Math.random()*60;
      obstacles.push({x:GAME_W + 40, y: groundY - h, w, h});
    }

    function update(dt){
      if(!running) return;
      // increase difficulty slowly
      speed += 0.0004 * dt;
      spdEl.textContent = (speed/6).toFixed(2);

      // Spawn obstacles
      spawnTimer -= dt;
      if(spawnTimer <= 0){
        spawnObstacle();
        spawnTimer = 700 + Math.random()*900 - Math.min(500, score*2); // faster as score grows
      }

      // Update obstacles
      for(let i=obstacles.length-1;i>=0;i--){
        obstacles[i].x -= speed*(dt/16);
        if(obstacles[i].x + obstacles[i].w < -50) obstacles.splice(i,1);
      }

      // Player physics
      player.vy += gravity*(dt/16);
      player.y += player.vy*(dt/16);
      if(player.y + player.h >= groundY){ player.y = groundY - player.h; player.vy = 0; player.onGround = true; }
      else player.onGround = false;

      // Score
      score += dt*0.02;
      scoreEl.textContent = Math.floor(score);

      // Collision
      for(let obs of obstacles){
        if(rectIntersect(player, obs)){
          gameOver(); break;
        }
      }
    }

    function rectIntersect(a,b){
      const ax = a.x, ay = a.y, aw = a.w, ah = a.h;
      const bx = b.x, by = b.y, bw = b.w, bh = b.h;
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,GAME_W,GAME_H);

      // background parallax
      drawParallax();

      // ground
      ctx.fillStyle = '#123048';
      ctx.fillRect(0, groundY, GAME_W, GAME_H-groundY);

      // player
      ctx.fillStyle = '#ffd166';
      ctx.fillRect(player.x, player.y, player.w, player.h);
      // face
      ctx.fillStyle = '#2b2d42';
      ctx.fillRect(player.x+12, player.y+18, 36, 12);

      // obstacles
      ctx.fillStyle = '#ef476f';
      for(let obs of obstacles) ctx.fillRect(obs.x, obs.y, obs.w, obs.h);

      // foreground: ground texture
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for(let i=0;i<GAME_W;i+=40) ctx.fillRect((i + (performance.now()/20)%40), groundY+60, 20, 6);
    }

    function drawParallax(){
      const t = performance.now()/1000;
      // sky gradient already in CSS; draw simple hills
      for(let layer=1;layer<=3;layer++){
        ctx.beginPath();
        const baseY = groundY - 20*layer;
        ctx.fillStyle = `rgba(2,30,50,${0.08*layer})`;
        ctx.moveTo(0, GAME_H);
        for(let x=0;x<=GAME_W;x+=40){
          const y = baseY - Math.sin((x/200) + t*0.2*layer)*40*layer;
          ctx.lineTo(x,y);
        }
        ctx.lineTo(GAME_W, GAME_H);
        ctx.closePath(); ctx.fill();
      }
    }

    let last = performance.now();
    function loop(now){
      const dt = Math.min(40, now-last);
      last = now;
      update(dt);
      draw();
      if(running) requestAnimationFrame(loop);
    }

    function gameOver(){
      running = false;
      finalScore.textContent = Math.floor(score);
      overlay.style.display = 'flex';
    }

    // Input handling
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space' || e.code === 'ArrowUp'){ jump(); e.preventDefault(); }
      if(e.code === 'KeyD' || e.code === 'ArrowDown'){ duck(true); }
    });
    window.addEventListener('keyup', (e)=>{ if(e.code === 'KeyD' || e.code === 'ArrowDown'){ duck(false); } });

    function jump(){
      if(!running){ reset(); return; }
      if(player.onGround){ player.vy = -18; player.onGround = false; }
    }
    function duck(d){ player.duck = d; if(d){ player.h = 48 } else { player.h = 80; player.y = Math.min(player.y, groundY - player.h); } }

    // Touch buttons
    jumpBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); jump(); });
    duckBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); duck(true); });
    duckBtn.addEventListener('touchend', (e)=>{ e.preventDefault(); duck(false); });

    // Auto-start
    loop(performance.now());

    // Responsive: if portrait, show rotate overlay (handled by CSS). But also show controls only on narrow screens
    function checkControls(){
      const controls = document.getElementById('controls');
      if(window.innerWidth < 700) controls.style.display = 'flex';
      else controls.style.display = 'none';
    }
    window.addEventListener('resize', checkControls); checkControls();

    // Simple tap to start if stopped
    canvas.addEventListener('click', ()=>{ if(!running) { reset(); loop(performance.now()); } });

    // Small accessibility: prevent overscroll on mobile
    document.addEventListener('touchmove', function(e){ if(e.target === document.body) e.preventDefault(); }, {passive:false});

  </script>
</body>
</html>
